import http from "k6/http";
import { check, sleep } from "k6";
import { SharedArray } from "k6/data";

const BASE_URL = "https://explorer.kaolin.hoodi.arkiv.network";
const READ_REQUESTS_PER_ITERATION = Number(
  __ENV.READ_REQUESTS_PER_ITERATION ?? 3
);
const MAX_BLOCK_HEIGHT = Number(__ENV.MAX_BLOCK_HEIGHT ?? 300_000);

// Load entity keys from the file generated by setup-entities.ts
const entityKeys = new SharedArray("entity_keys", function () {
  try {
    const data = JSON.parse(open("./entity-keys.json"));
    console.log(
      `Loaded ${data.entityKeys.length} entity keys created at ${data.createdAt}`
    );
    return data.entityKeys;
  } catch (error) {
    console.warn("Could not load entity-keys.json, will skip entity checks");
    return [];
  }
});

export const options = {
  scenarios: {
    warmup: {
      executor: "ramping-vus",
      startVUs: 1,
      stages: [{ duration: "1m", target: 5 }],
      gracefulRampDown: "30s",
      tags: { stage: "warmup" },
    },
    load_25: {
      executor: "ramping-vus",
      startVUs: 5,
      stages: [{ duration: "2m", target: 25 }],
      gracefulRampDown: "30s",
      startTime: "1m",
      tags: { stage: "load_25" },
    },
    load_50: {
      executor: "ramping-vus",
      startVUs: 25,
      stages: [{ duration: "2m", target: 50 }],
      gracefulRampDown: "30s",
      startTime: "3m",
      tags: { stage: "load_50" },
    },
    load_100: {
      executor: "ramping-vus",
      startVUs: 50,
      stages: [{ duration: "2m", target: 100 }],
      gracefulRampDown: "30s",
      startTime: "5m",
      tags: { stage: "load_100" },
    },
    load_200: {
      executor: "ramping-vus",
      startVUs: 100,
      stages: [{ duration: "2m", target: 200 }],
      gracefulRampDown: "30s",
      startTime: "7m",
      tags: { stage: "load_200" },
    },
    load_400: {
      executor: "ramping-vus",
      startVUs: 200,
      stages: [{ duration: "2m", target: 400 }],
      gracefulRampDown: "30s",
      startTime: "9m",
      tags: { stage: "load_400" },
    },
  },
  thresholds: {
    // Global thresholds
    http_req_failed: ["rate<0.05"],
    http_req_duration: ["p(95)<500"],

    // Per-stage thresholds
    "http_req_failed{stage:warmup}": ["rate<0.05"],
    "http_req_duration{stage:warmup}": ["p(95)<500"],

    "http_req_failed{stage:load_25}": ["rate<0.05"],
    "http_req_duration{stage:load_25}": ["p(95)<500"],

    "http_req_failed{stage:load_50}": ["rate<0.05"],
    "http_req_duration{stage:load_50}": ["p(95)<500"],

    "http_req_failed{stage:load_100}": ["rate<0.05"],
    "http_req_duration{stage:load_100}": ["p(95)<500"],

    "http_req_failed{stage:load_200}": ["rate<0.05"],
    "http_req_duration{stage:load_200}": ["p(95)<500"],

    "http_req_failed{stage:load_400}": ["rate<0.05"],
    "http_req_duration{stage:load_400}": ["p(95)<500"],
  },
};

function randomInt(min: number, max: number) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function randomHex(length: number) {
  let result = "";
  for (let i = 0; i < length; i += 1) {
    result += randomInt(0, 15).toString(16);
  }
  return result;
}

function randomItem<T>(items: T[]): T {
  if (items.length === 0) {
    throw new Error("Cannot pick an item from an empty list.");
  }
  return items[randomInt(0, items.length - 1)] as T;
}

const READ_ACTIONS = [
  () =>
    http.get(
      `${BASE_URL}/arkiv-indexer/api/v1/entities?string_annotation_key=random-key-${randomInt(
        0,
        1_000_000
      )}&string_annotation_value=random-value-${randomInt(
        0,
        1_000_000
      )}&status=ACTIVE`,
      { tags: { name: "search_by_string_annotation" } }
    ),
  () =>
    http.get(
      `${BASE_URL}/arkiv-indexer/api/v1/entities?numeric_annotation_key=random-numeric-${randomInt(
        0,
        10_000
      )}&numeric_annotation_value=${randomInt(0, 1_000_000)}&status=ACTIVE`,
      { tags: { name: "search_by_numeric_annotation" } }
    ),
  () => {
    if (entityKeys.length === 0) {
      // Fallback to random if no entities loaded
      return http.get(
        `${BASE_URL}/arkiv-indexer/api/v1/entity/${randomHex(64)}`,
        {
          tags: { name: "get_entity_by_id" },
        }
      );
    }
    const entityKey = randomItem(entityKeys);
    return http.get(`${BASE_URL}/arkiv-indexer/api/v1/entity/${entityKey}`, {
      tags: { name: "get_entity_by_id" },
    });
  },
  () => {
    const address = `0x${randomHex(40)}`;
    return http.get(`${BASE_URL}/api/v2/addresses/${address}`, {
      tags: { name: "get_address" },
    });
  },
  () => {
    const address = `0x${randomHex(40)}`;
    return http.get(`${BASE_URL}/api/v2/addresses/${address}/transactions`, {
      tags: { name: "get_address_transactions" },
    });
  },
  () => {
    const owner = `0x${randomHex(40)}`;
    return http.get(
      `${BASE_URL}/arkiv-indexer/api/v1/entities?status=ALL&owner=${owner}`,
      { tags: { name: "search_by_owner" } }
    );
  },
  () =>
    http.get(`${BASE_URL}/api/v2/blocks/${randomInt(0, MAX_BLOCK_HEIGHT)}`, {
      tags: { name: "get_block" },
    }),
];

function requestRandomData() {
  const response = randomItem(READ_ACTIONS)();

  check(response, {
    "read request responded": (res) => res.status !== 0 && res.status < 500,
  });
}

export default function () {
  for (let i = 0; i < READ_REQUESTS_PER_ITERATION; i += 1) {
    requestRandomData();
  }

  sleep(1);
}
